import { OllamaModel, Message, ChatSettings } from '../types';class OllamaService {  private baseUrl = 'http://localhost:11434';  async getModels(): Promise<OllamaModel[]> {    try {      const response = await fetch(`${this.baseUrl}/api/tags`);      if (!response.ok) {        throw new Error('Failed to fetch models from Ollama API');      }      const data = await response.json();      return data.models.map((model: any) => ({        name: model.name,        displayName: model.name,        size: this.formatBytes(model.size),        modified: new Date(model.modified_at),        parameters: {          temperature: 0.7,          top_p: 0.9,          top_k: 40,          repeat_penalty: 1.1,        },      }));    } catch (error) {      console.error('Error fetching models:', error);      return [];    }  }  async *streamChat(    messages: Message[],    settings: ChatSettings,    onToken?: (token: string) => void  ): AsyncGenerator<string, void, unknown> {    const response = await fetch(`${this.baseUrl}/api/chat`, {      method: 'POST',      headers: {        'Content-Type': 'application/json',      },      body: JSON.stringify({        model: settings.model,        messages: messages.map(msg => ({ role: msg.role, content: msg.content })),        stream: true,        options: {          temperature: settings.temperature,          top_p: settings.top_p,          top_k: settings.top_k,          repeat_penalty: settings.repeat_penalty,          num_ctx: settings.max_tokens,        },      }),    });    if (!response.body) {      return;    }    const reader = response.body.getReader();    const decoder = new TextDecoder();    while (true) {      const { done, value } = await reader.read();      if (done) {        break;      }      const chunk = decoder.decode(value);      const lines = chunk.split('\n');      for (const line of lines) {        if (line.trim() === '') continue;        const parsed = JSON.parse(line);        if (parsed.message && parsed.message.content) {          if (onToken) {            onToken(parsed.message.content);          }          yield parsed.message.content;        }      }    }  }  async checkConnection(): Promise<boolean> {    try {      const response = await fetch(this.baseUrl);      return response.ok;    } catch (error) {      return false;    }  }  private formatBytes(bytes: number, decimals = 2): string {    if (bytes === 0) return '0 Bytes';    const k = 1024;    const dm = decimals < 0 ? 0 : decimals;    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];    const i = Math.floor(Math.log(bytes) / Math.log(k));    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];  }}export const ollamaService = new OllamaService();